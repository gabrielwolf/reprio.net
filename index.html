<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>reprio.net - Your personal priority queue</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Avenir Next, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Arial, sans-serif;
            font-size: 15px;
            line-height: 1.6;
        }

        header, main, footer {
            padding: 1rem;
        }

        main {
            padding: 4rem;
            background: #def;
        }

        h1, h2 {
            font-weight: 500;
        }

        h1 {
            font-size: clamp(2rem, 4vw + 1rem, 2.5rem);
            margin: -0.8rem 0 0 0;
        }

        h2 {
            margin: 0.2rem 0;
        }

        p {
            font-size: 1rem;
            line-height: 1.6;
        }

        input {
            padding: 0.5rem;
        }

        #taskInput {
            width: auto;
        }

        table {
            width: 100%;
            margin-top: 1rem;
            border-collapse: collapse;
        }

        th, td {
            border: 1px solid #aaa;
            padding: 0.5rem;
        }

        th {
            text-align: left;
            background-color: #eee;
        }

        th:nth-child(2),
        th:nth-child(3),
        td:nth-child(2),
        td:nth-child(3) {
            text-align: center;
            width: 1%;
            white-space: nowrap;
        }

        th:nth-child(1) {
            width: auto;
        }

        td[contenteditable="true"] {
            outline: none;
        }

        td {
            background-color: #fafafa;
        }

        button {
            cursor: pointer;
        }
    </style>
</head>
<body>
<header>
    <h1>reprio.net</h1>
    <h2>A simple online priority queue for organising your tasks</h2>
    <ul>
        <li>Add a task: 1. Type it 2. Type the priority 3. Press return.</li>
        <li>Change a task: 1. Select it 2. Change it. 3. Leave the cell.</li>
        <li>Security: Your data is stored in the browser (via localStorage).<br>
            Press reset, or delete your browser’s cache and you’re safe.<br>
            But remember, everyone with access to your computer and browser can read as long as data is stored... no magic here.
        </li>
        <li>Backup: Press the import and export buttons. (Downloads a file in JSON format.)</li>
    </ul>
    <p>That’s it. Happy prioritising! :)</p>
</header>
<main>
    <div style="display: flex; align-items: center; width: 100%; gap: 0.5rem;">
        <label for="taskInput" style="position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0;">Task</label>
        <input type="text" id="taskInput" placeholder="Write your task here..." style="flex: 1;">
        <label for="priorityInput" style="position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0;">Priority</label>
        <input type="number" id="priorityInput" min="1" max="10" placeholder="1-10" style="width: 5rem;">
    </div>
    <table id="queueTable">
        <thead>
        <tr>
            <th>Task</th>
            <th>Priority</th>
            <th>Action</th>
        </tr>
        </thead>
        <tbody></tbody>
    </table>
    <br>
    <div>
        <button id="resetBtn">Reset</button>
        <button id="exportBtn">Export (.json)</button>
        <button id="importBtn">Import (.json)</button>
        <input type="file" id="fileInput" accept="application/json" style="display:none">
    </div>
</main>
<footer>
    A non-commercial <a href="https://github.com/gabrielwolf/reprio.net">open source experiment</a> by Gabriel Wolf
</footer>
<script>
    const taskInput = document.getElementById("taskInput");
    const priorityInput = document.getElementById("priorityInput");
    const tableBody = document.querySelector("#queueTable tbody");
    const resetBtn = document.getElementById("resetBtn");
    const exportBtn = document.getElementById("exportBtn");
    const importBtn = document.getElementById("importBtn");
    const fileInput = document.getElementById("fileInput");

    // Generate stable ids for rows (needed to restore focus after re-render)
    function newId() {
        if (window.crypto && typeof window.crypto.randomUUID === "function") return window.crypto.randomUUID();
        return String(Date.now()) + "-" + Math.random().toString(16).slice(2);
    }

    function saveQueue() {
        localStorage.setItem("queue", JSON.stringify(queue));
    }

    // When we re-render (e.g. after changing priority), we can restore focus to the next cell
    let pendingFocus = null; // { itemId: string, field: "task" | "priority" }

    function placeCaretAtEnd(el) {
        const range = document.createRange();
        range.selectNodeContents(el);
        range.collapse(false);
        const sel = window.getSelection();
        if (!sel) return;
        sel.removeAllRanges();
        sel.addRange(range);
    }

    function focusEditableCell(itemId, field) {
        if (!itemId || !field) return;
        const selector = `td[contenteditable="true"][data-item-id="${itemId}"][data-field="${field}"]`;
        const cell = tableBody.querySelector(selector);
        if (!cell) return;
        cell.focus();
        placeCaretAtEnd(cell);
    }

    function handleEditableTab(e) {
        if (e.key !== "Tab") return;
        const cells = Array.from(tableBody.querySelectorAll('td[contenteditable="true"]'));
        const current = e.currentTarget;
        const idx = cells.indexOf(current);
        if (idx === -1 || cells.length === 0) return;

        const dir = e.shiftKey ? -1 : 1;
        const next = cells[(idx + dir + cells.length) % cells.length];

        // Remember where we want to go in case a blur triggers renderTable()
        pendingFocus = { itemId: next.dataset.itemId, field: next.dataset.field };

        e.preventDefault();
        next.focus();
        placeCaretAtEnd(next);
    }

    // Insert plain text at the current caret position (avoids HTML insertion and keeps the cursor stable)
    function insertTextAtCursor(text) {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) return;
        const range = sel.getRangeAt(0);
        range.deleteContents();
        range.insertNode(document.createTextNode(text));
        range.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range);
    }

    // Load queue from localStorage or use default if empty
    let queue = JSON.parse(localStorage.getItem("queue"));
    if (!queue || !Array.isArray(queue) || queue.length === 0) {
        queue = [
            { id: newId(), task: "Go to bed early", priority: 1 },
            { id: newId(), task: "Offer someone a hug", priority: 2 },
            { id: newId(), task: "By flowers", priority: 3 }
        ];
        saveQueue();
    }

    // Backward-compatible: add missing ids
    queue = queue.map((item) => ({
        id: item && item.id ? String(item.id) : newId(),
        task: String(item && item.task != null ? item.task : ""),
        priority: parseInt(item && item.priority != null ? item.priority : 10)
    }));
    saveQueue();

    function renderTable() {
        queue.sort((a, b) => a.priority - b.priority);
        tableBody.innerHTML = "";

        queue.forEach((item, index) => {
            const row = document.createElement("tr");

            const taskCell = document.createElement("td");
            taskCell.textContent = item.task;
            taskCell.contentEditable = "true";
            taskCell.setAttribute("spellcheck", "false");
            taskCell.tabIndex = 0;
            taskCell.dataset.itemId = item.id;
            taskCell.dataset.field = "task";

            taskCell.addEventListener("paste", (e) => {
                e.preventDefault();
                const text = (e.clipboardData || window.clipboardData).getData("text/plain");
                insertTextAtCursor(text);
            });
            taskCell.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    taskCell.blur();
                    return;
                }
                handleEditableTab(e);
            });
            taskCell.addEventListener("blur", () => {
                queue[index].task = taskCell.textContent;
                saveQueue();
            });

            const priorityCell = document.createElement("td");
            priorityCell.textContent = item.priority;
            priorityCell.contentEditable = "true";
            priorityCell.setAttribute("spellcheck", "false");
            priorityCell.tabIndex = 0;
            priorityCell.dataset.itemId = item.id;
            priorityCell.dataset.field = "priority";

            priorityCell.addEventListener("paste", (e) => {
                e.preventDefault();
                const text = (e.clipboardData || window.clipboardData).getData("text/plain");
                insertTextAtCursor(text);
            });
            priorityCell.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    priorityCell.blur();
                    return;
                }
                handleEditableTab(e);
            });
            priorityCell.addEventListener("blur", () => {
                let newValue = parseInt(priorityCell.textContent);
                if (!isNaN(newValue) && newValue >= 1 && newValue <= 10) {
                    queue[index].priority = newValue;
                } else {
                    priorityCell.textContent = queue[index].priority;
                    alert("Bitte eine Zahl zwischen 1 und 10 eingeben!");
                }
                renderTable();
            });

            const actionCell = document.createElement("td");
            const delBtn = document.createElement("button");
            delBtn.textContent = "Delete";
            delBtn.addEventListener("click", () => deleteTask(index));
            actionCell.appendChild(delBtn);

            row.appendChild(taskCell);
            row.appendChild(priorityCell);
            row.appendChild(actionCell);
            tableBody.appendChild(row);
        });

        saveQueue();

        if (pendingFocus) {
            const { itemId, field } = pendingFocus;
            pendingFocus = null;
            setTimeout(() => focusEditableCell(itemId, field), 0);
        }
    }

    function addToQueue() {
        const task = taskInput.value.trim();
        const priority = parseInt(priorityInput.value);
        if (task && !isNaN(priority) && priority >= 1 && priority <= 10) {
            queue.push({ id: newId(), task, priority });
            renderTable();
            taskInput.value = "";
            priorityInput.value = "";
            taskInput.focus();
        }
    }

    function deleteTask(index) {
        queue.splice(index, 1);
        renderTable();
    }

    // Reset
    resetBtn.addEventListener("click", () => {
        if (confirm("Do you really want to delete everything?")) {
            queue = [];
            renderTable();
        }
    });

    // Export
    exportBtn.addEventListener("click", () => {
        const blob = new Blob([JSON.stringify(queue, null, 2)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "todo-queue.json";
        a.click();
        URL.revokeObjectURL(url);
    });

    // Import
    importBtn.addEventListener("click", () => {
        fileInput.click();
    });

    fileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const imported = JSON.parse(String(event.target.result));
                if (Array.isArray(imported)) {
                    queue = imported.map(item => ({
                        id: item && item.id ? String(item.id) : newId(),
                        task: String(item && item.task != null ? item.task : ""),
                        priority: parseInt(item && item.priority != null ? item.priority : 10)
                    }));
                    renderTable();
                } else {
                    alert("Invalid JSON format!");
                }
            } catch (err) {
                alert("Error during import: " + err.message);
            }
        };
        reader.readAsText(file);
        fileInput.value = ""; // reset for next import
    });

    taskInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            e.preventDefault();
            addToQueue();
        }
    });
    priorityInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            e.preventDefault();
            addToQueue();
            return;
        }

        // Allow creating a task via Tab when the inputs are valid.
        // Only handle forward Tab (Shift+Tab should behave normally).
        if (e.key === "Tab" && !e.shiftKey) {
            const task = taskInput.value.trim();
            const priority = parseInt(priorityInput.value);
            const isValidPriority = !isNaN(priority) && priority >= 1 && priority <= 10;

            if (task && isValidPriority) {
                e.preventDefault();
                addToQueue();
            }
        }
    });

    renderTable();
</script>
</body>
</html>
